'''
psychoacoustics exports classes for handling psychophysical procedures and
measures, like trial sequences and staircases.
This module uses doctests. Use like so:
python -m doctest psychoacoustics.py
'''
import os
from pathlib import Path
import datetime
import json
import zipfile
from contextlib import contextmanager
try:
    import curses
    have_curses = True
except ImportError:
    have_curses = False
import collections
import numpy
try:
    import matplotlib.pyplot as plt
    have_pyplot = True
except ImportError:
    have_pyplot = False
import slab

results_folder = 'Results'


@contextmanager
def Key():
    '''
    Wrapper for curses module to simplify getting a single keypress from the terminal.
    Use like this:
    with slab.Key() as key:
            response = key.getch()
    '''
    if not have_curses:
        raise ImportError(
            'You need curses to use the keypress class (pip install curses (or windows-curses))')
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    yield stdscr
    curses.nocbreak()
    curses.echo()
    curses.endwin()


class LoadSaveJson:
    'Mixin to provide JSON loading and saving functions'

    def save_json(self, file_name=None):
        """
        Serialize the object to the JSON format.
        fileName: string, or None
                the name of the file to create or append. If `None`,
                will not write to a file, but return an in-memory JSON object.
        """
        # self_copy = copy.deepcopy(self) use if reading the json file sometimes fails
        def default(o): return int(o) if isinstance(o, numpy.int64) else o
        if (file_name is None) or (file_name == 'stdout'):
            return json.dumps(self.__dict__, indent=2, default=default)
        else:
            try:
                with open(file_name, 'w') as f:
                    json.dump(self.__dict__, f, indent=2, default=default)
                    return 1
            except OSError:
                return -1

    def load_json(self, file_name):
        """
        Read JSON file and deserialize the object into self.__dict__.
        file_name: string, the name of the file to read.
        """
        with open(file_name, 'r') as f:
            self.__dict__ = json.load(f)


class Trialsequence(collections.abc.Iterator, LoadSaveJson):  # TODO: correct string conditions!
    """Non-adaptive trial sequences
    Parameters:
    conditions: an integer, list, or flat array specifying condition indices,
            or a list strings specifying condition names, or a list of
            dictionaries with values for each condition index.
            If given an integer x, uses range(x).
            If conditions is a string, then it is treated as the name of a previously
            saved trial sequence object, which is then loaded.
    n_reps: number of repeats for all conditions
    trials: a list of condition indices, i.e. the trial sequence. Typically, this
            list is left empty and generated by the class based on the other parameters.
    kind: The kind of sequence randomization used to generate the trial sequence.
            'non-repeating' (conditions are repeated in randome order n_reps times without
            direct repetition - default if n_conds > 2), or 'random_permutation' (
            conditions are permuted randomly without control over transition probabilities
            - default if n_conds <= 2).
    name: a text label for the sequence.

    Attributes:
    .n_trials - the total number of trials that will be run
    .n_remaining - the total number of trials remaining
    .this_n - total trials completed so far
    .this_rep_n - which repeat you are currently on
    .this_trial_n - which trial number *within* that repeat
    .this_trial - a dictionary giving the parameters of the current trial
    .finished - True/False for have we finished yet
"""

    def __init__(self, conditions=2, n_reps=1, trials=[], kind=None, name=''):
        self.name = name
        self.n_reps = int(n_reps)
        self.conditions = conditions
        if isinstance(conditions, str) and os.path.isfile(conditions):
            self.load_json(conditions)  # import entire object from file
        elif isinstance(conditions, int):
            self.conditions = list(range(conditions))
        else:
            self.conditions = conditions
        self.n_conds = len(self.conditions)
        self.this_rep_n = 0  # records which repetition or pass we are on
        self.this_trial_n = -1  # records trial number within this repetition
        self.this_n = -1
        self.this_trial = []
        self.finished = False
        # generate stimulus sequence
        if not trials:
            if not kind:
                kind = 'random_permutation' if self.n_conds <= 2 else 'non_repeating'
            if kind == 'non_repeating':
                trials = Trialsequence._create_simple_sequence(len(self.conditions), self.n_reps)
            elif kind == 'random_permutation':
                trials = Trialsequence._create_random_permutation(len(self.conditions), self.n_reps)
            else:
                raise ValueError(f'Unknown kind parameter: {kind}!')
        self.trials = trials
        self.n_trials = len(self.trials)
        self.n_remaining = self.n_trials  # subtract 1 each trial

    def __repr__(self):
        return self.__dict__.__repr__()

    def __str__(self):
        return f'Trialsequence, trials {self.n_trials}, remaining {self.n_remaining}, current condition {self.this_trial}'

    def __next__(self):
        """Advances to next trial and returns it.
        Updates attributes; this_trial, this_trial_n
        If the trials have ended this method will raise a StopIteration error.
        trials = Trialsequence(.......)
                for eachTrial in trials:  # automatically stops when done
        """
        self.this_trial_n += 1  # number of trial this pass
        self.this_n += 1  # number of trial in total
        self.n_remaining -= 1
        if self.this_trial_n >= self.n_conds and (self.n_reps > 1):
            self.this_trial_n = 0  # start a new repetition
            self.this_rep_n += 1
        if self.this_n >= len(self.trials):  # all trials complete
            self.this_trial = []
            self.finished = True
        if self.finished:
            raise StopIteration
        self.this_trial = self.conditions[self.trials[self.this_n]]  # fetch the trial info
        return self.this_trial

    @staticmethod
    def _create_simple_sequence(n_conditions, n_reps):
        '''Create a sequence of n_conditions x n_reps trials, where each repetitions
        contains all conditions in random order, and no condition is directly
        repeated across repetitions.'''
        permute = list(range(n_conditions))
        trials = []
        for rep in range(n_reps):
            numpy.random.shuffle(permute)
            if rep == 0:  # first repetition
                trials.extend(permute)
            else:
                while trials[-1] == permute[0]:
                    permute = list(range(n_conditions))
                    numpy.random.shuffle(permute)
                trials.extend(permute)
        return trials

    @staticmethod
    def _create_random_permutation(n_conditions, n_reps):
        '''Create a sequence of n_conditions x n_reps trials in random order.'''
        return list(numpy.random.permutation(numpy.tile(list(range(n_conditions)), n_reps)))

    def get_future_trial(self, n=1):
        """Returns the condition for n trials into the future or past,
        without advancing the trials. A negative n returns a previous (past)
        trial. Returns 'None' if attempting to go beyond the last trial.
        """
        if n > self.n_remaining or self.this_n + n < 0:
            return None
        return self.conditions[self.trials[self.this_n + n]]

    def transitions(self):
        'Return array (n_conds x n_conds) of transition probabilities.'
        transitions = numpy.zeros((self.n_conds, self.n_conds))
        for i, j in zip(self.trials, self.trials[1:]):
            transitions[i, j] += 1
        return transitions

    def condition_probabilities(self):
        'Return list of frequencies of conditions in the order listed in .conditions'
        probs = []
        for i in range(self.n_conds):
            num = self.trials.count(i)
            num /= self.n_trials
            probs.append(num)
        return probs

    def plot(self):
        'Plot the trial sequence as scatter plot.'
        if not have_pyplot:
            raise ImportError('Plotting requires matplotlib!')
        plt.plot(self.trials)
        plt.xlabel('Trials')
        plt.ylabel('Condition index')
        plt.show()

    @staticmethod
    def mmn_sequence(n_trials, deviant_freq=0.12):
        '''Returns a  MMN experiment: 2 different stimuli (conditions),
        between two deviants at least 3 standards
        n_trials: number of trials to return
        deviant_freq: frequency of deviants (*0.12*, max. 0.25)
        '''
        n_partials = int(numpy.ceil((2 / deviant_freq) - 7))
        reps = int(numpy.ceil(n_trials/n_partials))
        partials = []
        for i in range(n_partials):
            partials.append([0] * (3+i) + [1])
        idx = list(range(n_partials)) * reps
        numpy.random.shuffle(idx)  # randomize order
        trials = []  # make the trial sequence by putting possibilities together
        for i in idx:
            trials.extend(partials[i])
        trials = trials[:n_trials]  # cut the list to the requested numner of trials
        return Trialsequence(conditions=2, n_reps=1, trials=trials)


class Staircase(collections.abc.Iterator):
    # TODO: add Kaernbach1991 weighted up-down method?
    # TODO: add QUEST or Bayesian estimation?
    """Class to handle smoothly the selection of the next trial
    and report current values etc.
    Calls to next() will fetch the next object given to this
    handler, according to the method specified.
    The staircase will terminate when *n_trials* AND *n_reversals* have
    been exceeded. If *step_sizes* was an array and has been exceeded
    before n_trials is exceeded then the staircase will continue
    to reverse.
    n_up and n_down are always considered as 1 until the first reversal
    is reached. The values entered as arguments are then used.
    Lewitt (1971) gives the up-down values for different threshold points
    on the psychometric function: 1-1 (0.5), 1-2 (0.707), 1-3 (0.794),
    1-4 (0.841), 1-5 (0.891).
    Example:
    >>> stairs = Staircase(start_val=50, n_reversals=10, step_type='lin',\
                    step_sizes=[4,2], min_val=10, max_val=60, n_up=1, n_down=1, n_trials=10)
    >>> print(stairs)
    <class 'psychoacoustics.Staircase'> 1up1down, trial -1, 0 reversals of 10
    >>> for trial in stairs:
    ... 	response = stairs.simulate_response(30)
    ... 	stairs.add_response(response)
    >>> print(f'reversals: {stairs.reversal_intensities}')
    reversals: [26, 30, 28, 30, 28, 30, 28, 30, 28, 30]
    >>> print(f'mean of final 6 reversals: {stairs.threshold()}')
    mean of final 6 reversals: 28.982753492378876
    """

    def __init__(self, start_val, n_reversals=None, step_sizes=4, n_pretrials=4, n_up=1,
                 n_down=2, step_type='lin', min_val=None, max_val=None, name=''):
        """
        :Parameters:
                name:
                        A text label.
                start_val:
                        The initial value for the staircase.
                n_reversals:
                        The minimum number of reversals permitted.
                        If `step_sizes` is a list, but the minimum number of
                        reversals to perform, `n_reversals`, is less than the
                        length of this list, PsychoPy will automatically increase
                        the minimum number of reversals and emit a warning.
                step_sizes:
                        The size of steps as a single value or a list (or array).
                        For a single value the step size is fixed. For an array or
                        list the step size will progress to the next entry
                        at each reversal.
                n_pretrials:
                        The number of pretrials presented as familiarization before
                        the actual experiment. start_val is used presentation level.
                n_up:
                        The number of 'incorrect' (or 0) responses before the
                        staircase level increases.
                n_down:
                        The number of 'correct' (or 1) responses before the
                        staircase level decreases.
                step_type: *'lin'*, 'db', 'log'
                        The type of steps that should be taken each time. 'lin'
                        will simply add or subtract that amount each step, 'db'
                        and 'log' will step by a certain number of decibels or
                        log units (note that this will prevent your value ever
                        reaching zero or less)
                min_val: *None*, or a number
                        The smallest legal value for the staircase, which can be
                        used to prevent it reaching impossible contrast values,
                        for instance.
                max_val: *None*, or a number
                        The largest legal value for the staircase, which can be
                        used to prevent it reaching impossible contrast values,
                        for instance.
        """
        self.name = name
        self.start_val = start_val
        self.n_up = n_up
        self.n_down = n_down
        self.step_type = step_type
        try:
            self.step_sizes = list(step_sizes)
        except TypeError:
            self.step_sizes = [step_sizes]
        self._variable_step = True if len(self.step_sizes) > 1 else False
        self.step_size_current = self.step_sizes[0]
        if n_reversals is None:
            self.n_reversals = len(self.step_sizes)
        elif len(self.step_sizes) > n_reversals:
            print(
                f'Increasing number of minimum required reversals to the number of step sizes, {len(self.step_sizes)}')
            self.n_reversals = len(self.step_sizes)
        else:
            self.n_reversals = n_reversals
        self.finished = False
        self.n_pretrials = n_pretrials
        self.this_trial_n = -n_pretrials
        self.data = []
        self.intensities = []
        self.reversal_points = []
        self.reversal_intensities = []
        self.current_direction = 'down'
        self.correct_counter = 0
        self._next_intensity = self.start_val
        self.min_val = min_val
        self.max_val = max_val
        self.pf_intensities = None  # psychometric function, auto set when finished
        self.pf_percent_correct = None  # psychometric function, auto set when finished
        self.pf_responses_per_intensity = None  # psychometric function, auto set when finished

    def __next__(self):
        """Advances to next trial and returns it.
        Updates attributes; `this_trial`, `this_trial_n` and `thisIndex`.
        If the trials have ended, calling this method will raise a
        StopIteration error. This can be handled with code such as::
                staircase = Staircase(.......)
                for eachTrial in staircase:  # automatically stops when done
                        # do stuff
        """
        if not self.finished:
            self.this_trial_n += 1  # update pointer for next trial
            self.intensities.append(self._next_intensity)
            return self._next_intensity
        else:
            self._psychometric_function()  # tally responses to create a psychometric function
            raise StopIteration

    def __repr__(self):
        return self.__dict__.__repr__()

    def __str__(self):
        return f'Staircase {self.n_up}up-{self.n_down}down, trial {self.this_trial_n}, {len(self.reversal_intensities)} reversals of {self.n_reversals}'

    def add_response(self, result, intensity=None):
        """Add a True or 1 to indicate a correct/detected trial
        or False or 0 to indicate an incorrect/missed trial.
        This is essential to advance the staircase to a new intensity level.
        Supplying an `intensity` value indicates that you did not use
        the recommended intensity in your last trial and the staircase will
        replace its recorded value with the one supplied.
        """
        if self._next_intensity <= self.min_val:  # always record False if at min_val
            result = False
        else:
            result = bool(result)
        self.data.append(result)
        if intensity is not None:
            self.intensities.pop()
            self.intensities.append(intensity)
        if self.this_trial_n > 0:  # we're out of the pretrials
            if result:  # correct response
                if len(self.data) > 1 and self.data[-2] == result:
                    self.correct_counter += 1  # increment if on a run
                else:
                    self.correct_counter = 1  # or reset
            else:  # incorrect response
                if len(self.data) > 1 and self.data[-2] == result:
                    self.correct_counter -= 1  # decrement if on a run
                else:
                    self.correct_counter = -1  # or reset
            self.calculatenext_intensity()

    def calculatenext_intensity(self):
        'Based on current intensity, counter of correct responses, and current direction.'
        if not self.reversal_intensities:  # no reversals yet
            if self.data[-1] is True:  # last answer correct
                reversal = bool(self.current_direction == 'up')  # got it right
                self.current_direction = 'down'
            else:  # got it wrong
                reversal = bool(self.current_direction == 'down')
                self.current_direction = 'up'
        elif self.correct_counter >= self.n_down:  # n right, time to go down!
            reversal = bool(self.current_direction != 'down')
            self.current_direction = 'down'
        elif self.correct_counter <= -self.n_up:  # n wrong, time to go up!
            reversal = bool(self.current_direction != 'up')
            self.current_direction = 'up'
        else:  # same as previous trial
            reversal = False
        if reversal:  # add reversal info
            self.reversal_points.append(self.this_trial_n)
            self.reversal_intensities.append(self.intensities[-1])
        if len(self.reversal_intensities) >= self.n_reversals:
            self.finished = True  # we're done
        if reversal and self._variable_step:  # new step size if necessary
            # if beyond the list of step sizes, use the last one
            if len(self.reversal_intensities) >= len(self.step_sizes):
                self.step_size_current = self.step_sizes[-1]
            else:
                _sz = len(self.reversal_intensities)
                self.step_size_current = self.step_sizes[_sz]
        if not self.reversal_intensities:
            if self.data[-1] == 1:
                self._intensity_dec()
            else:
                self._intensity_inc()
        elif self.correct_counter >= self.n_down:
            self._intensity_dec()  # n right, so going down
        elif self.correct_counter <= -self.n_up:
            self._intensity_inc()  # n wrong, so going up

    def _intensity_inc(self):
        'increment the current intensity and reset counter'
        if self.step_type == 'db':
            self._next_intensity *= 10.0**(self.step_size_current/20.0)
        elif self.step_type == 'log':
            self._next_intensity *= 10.0**self.step_size_current
        elif self.step_type == 'lin':
            self._next_intensity += self.step_size_current
        if (self.max_val is not None) and (self._next_intensity > self.max_val):
            self._next_intensity = self.max_val  # check we haven't gone out of the legal range
        self.correct_counter = 0

    def _intensity_dec(self):
        'decrement the current intensity and reset counter'
        if self.step_type == 'db':
            self._next_intensity /= 10.0**(self.step_size_current/20.0)
        if self.step_type == 'log':
            self._next_intensity /= 10.0**self.step_size_current
        elif self.step_type == 'lin':
            self._next_intensity -= self.step_size_current
        self.correct_counter = 0
        if (self.min_val is not None) and (self._next_intensity < self.min_val):
            self._next_intensity = self.min_val  # check we haven't gone out of the legal range

    def simulate_response(self, thresh):
        # TODO: use psychometric function (Weibull?) to generate responses
        'Return a simulated response dependent on thresh and self.'
        return self._next_intensity >= thresh

    def threshold(self, n=6):
        '''Returns the average (arithmetic for step_type == 'lin',
        geometric otherwise) of the last n reversals (default 6).'''
        if self.finished:
            if n > self.n_reversals:
                n = self.n_reversals
            if self.step_type == 'lin':
                return numpy.mean(self.reversal_intensities[-n:])
            else:
                return numpy.exp(numpy.mean(numpy.log(self.reversal_intensities[-n:])))

    def print_trial_info(self):
        print(
            f'trial # {self.this_trial_n}: reversals: {len(self.reversal_points)}/{self.n_reversals}, intensity {round(self.intensities[-1],2) if self.intensities else round(self._next_intensity,2)}, going {self.current_direction}, response {self.data[-1] if self.data else None}')

    def save_csv(self, fileName):
        'Write a text file with the data.'
        if self.this_trial_n < 1:
            return -1  # no trials to save
        with open(fileName, 'w') as f:
            raw_intens = str(self.intensities)
            raw_intens = raw_intens.replace('[', '').replace(']', '')
            f.write(raw_intens)
            f.write('\n')
            responses = str(numpy.multiply(self.data, 1))  # convert to 0 / 1
            responses = responses.replace('[', '').replace(']', '')
            responses = responses.replace(' ', ', ')
            f.write(responses)

    def plot(self):
        'Plot the staircase. If called after each trial, one plot is created and updated.'
        if not have_pyplot:
            raise ImportError('Plotting requires matplotlib!')
        x = numpy.arange(-self.n_pretrials, len(self.intensities)-self.n_pretrials)
        y = numpy.array(self.intensities)
        responses = numpy.array(self.data)
        fig = plt.figure('stairs')  # figure 'stairs' is created or made current
        plt.clf()
        plt.plot(x, y)
        ax = plt.gca()
        ax.set_xlim(-self.n_pretrials, min(20, (self.this_trial_n + 15)//10*10))  # plot
        ax.set_ylim(self.min_val, self.max_val)
        # plot green dots at correct/yes responses
        ax.scatter(x[responses], y[responses], color='green')
        # plot red dots at correct/yes responses
        ax.scatter(x[~responses], y[~responses], color='red')
        ax.set_ylabel('Dependent variable')
        ax.set_xlabel('Trial')
        ax.set_title('Staircase')
        if self.finished:
            plt.hlines(self.threshold(), min(x), max(x), 'r')
        plt.draw()
        plt.pause(0.1)
        # if self.pf_intensities and plot_pf:
        #	_, (ax1, ax2) = plt.subplots(1, 2, sharey='row', gridspec_kw={'width_ratios':[2, 1], 'wspace':0.1}, num='stairs') # prepare a second panel for the pf plot
        #ax2.plot(self.pf_percent_correct, self.pf_intensities)
        # point_sizes = self.pf_responses_per_intensity * 5 # 5 pixels per trial at each point
        #ax2.scatter(self.pf_percent_correct, self.pf_intensities, s=point_sizes)
        #ax2.set_xlabel('Hit rate')
        # ax2.set_title('Psychometric\nfunction')

    def close_plot(self):
        plt.close('stairs')

    def _psychometric_function(self):
        """Create a psychometric function by binning data from a staircase
        procedure. Called automatically when staircase is finished. Sets
        pf_intensites
                        a numpy array of intensity values (where each is the center
                        of an intensity bin)
        pf_percent_correct
                        a numpy array of mean percent correct in each bin
        pf_responses_per_intensity
                        a numpy array of number of responses contributing to each mean
        """
        intensities = numpy.array(self.intensities)
        responses = numpy.array(self.data)
        binned_resp = []
        binned_intens = []
        n_points = []
        intensities = numpy.round(intensities, decimals=8)
        unique_intens = numpy.unique(intensities)
        for this_intens in unique_intens:
            these_resps = responses[intensities == this_intens]
            binned_intens.append(this_intens)
            binned_resp.append(numpy.mean(these_resps))
            n_points.append(len(these_resps))
        self.pf_intensities = binned_intens
        self.pf_percent_correct = binned_resp
        self.pf_responses_per_intensity = n_points

    def present_afc_trial(self, target, distractors, key_codes=(range(48, 58)), isi=0.25, print_info=True):
        '''
        Present the target (slab sound object) in random order together
        with the distractor sound object (or list of several sounds) with
        isi pause (in seconds) in between, then aquire a response keypress
        via Key(), compare the response to the target interval and record
        the response via add_response. If key_codes for buttons are given
        (get with: ord('1') for instance -> ascii code of key 1 is 49),
        then these keys will be used as answer keys. Default are codes for
        buttons '1' to '9'.
        This is a convenience function for implementing alternative forced
        choice trials. In each trial, generate the target stimulus and
        distractors, then call present_afc_trial to play them and record
        the response. Optionally call print_trial_info afterwards.
        '''
        if isinstance(distractors, list):
            stims = [target].extend(distractors)  # assuming sound object and list of sounds
        else:
            stims = [target, distractors]  # assuming two sound objects
        order = numpy.random.permutation(len(stims))
        for idx in order:
            stim = stims[idx]
            stim.play()
            plt.pause(isi)
        with Key() as key:
            response = key.getch()
        interval = numpy.where(order == 0)[0][0]
        interval_key = key_codes[interval]
        response = response == interval_key
        self.add_response(response)
        if print_info:
            self.print_trial_info()

    def present_tone_trial(self, stimulus, correct_key_idx, key_codes=(range(48, 58)), print_info=True):
        stimulus.play()
        with slab.Key() as key:
            response = key.getch()
        response = response == key_codes[correct_key_idx]
        self.add_response(response)
        if print_info:
            self.print_trial_info()


class Resultsfile():
    '''
    A class for simplifying the typical use cases of results files, including generating the name,
    creating the folders, and writing to the file after each trial.
    Examples:
    >>> Resultsfile.results_folder = 'MyResults'
    >>> file = Resultsfile(subject='MS')
    >>> print(file.name)
    '''
    name = property(fget=lambda self: str(self.path.name), doc='The name of the results file.')

    def __init__(self, subject='test'):
        self.subject = subject
        self.path = Path(results_folder / Path(subject) / Path(subject +
                                                               datetime.datetime.now().strftime("_%Y-%m-%d-%H-%M-%S") + '.txt'))
        # make the Results folder and subject subfolder
        self.path.parent.mkdir(parents=True, exist_ok=True)

    def write(self, data, tag=None):
        '''
        Safely write data (must be lines of text or convertable to lines of text) to the file.
        The file is opened just before writing and closed immediately after to avoid data loss.
        Call this method at the end of each trial to save the response and trial state.
        A tag (any string or 'time') can be prepended. If tag='time', the current time is prepended.
        '''
        if not isinstance(data, str):
            data = str(data)
        if tag == 'time':
            tag = datetime.datetime.now().strftime("time: %Y-%m-%d-%H-%M-%S")
        with open(self.path, 'a') as file:
            if tag is not None:
                file.write('tag: ' + str(tag) + '\n')
            file.write(data)
            file.write('\n')

    def clear(self):
        'Clears the file by erasing all content.'
        with open(self.path, 'w') as file:
            file.write('')


class Precomputed(list):
    '''
    Class for randomly playing pre-computed sound stimuli without direct repetition.
    'sounds' can be a list of Sound objects, a function, or an iterable.
    This class simplifies generation and presentation of pre-computed sound stimuli
    and is typically used when stimulus generation takes too long to happen in each trial.
    In this case, a list of stimuli is precomputed and a random stimulus from the list is
    presented in each trial, ideally without direct repetition.
    The class allows easy generation of such stimulus lists (type 'slab.Precomputed') and
    keeps track of the previously presented stimulus. The list has a play method which
    automatically selects an element other than the previous one for playing, and
    can be used like an slab.Sound object.
    'sounds': [list|callable|iterator], the stimulus objects (must have a play method)
    'n': [int, *10*], only used if list is a callable, calls it n times to make the stimuli
    Examples:
    >>> stims = slab.Precomputed(sound_list) # using a pre-made list
    >>> stims = slab.Precomputed(lambda: slab.Sound.pinknoise(), n=10) # using a lambda function
    >>> # to make 10 examples of pink noise
    >>> stims = slab.Precomputed( (slab.Sound.vowel(vowel=v) for v in ['a','e','i']) ) # using a generator
    >>> stims.play() # playing a sound from the list
    '''

    def __init__(self, sounds, n=10):
        if isinstance(sounds, (list, tuple)):  # a list was passed, use as is
            list.__init__(self, sounds)
        elif callable(sounds):  # a function to generate sound objects was passed, call the function n times
            list.__init__(self, [])
            for _ in range(int(n)):
                list.append(self, sounds())
        elif isinstance(sounds, str):  # string is interpreted as name of a zip file containing the sounds
            with zipfile.ZipFile(sounds) as zip:
                files = zip.namelist()
                if files:
                    list.__init__(self, [])
                    for file in files:
                        list.append(self, slab.Sound(file))
        elif hasattr(sounds, '__iter__'):  # it's an iterable object, just iterate through it
            for sound in sounds:
                list.append(self, sound)
        else:
            raise TypeError('Unknown type for list argument.')
        self.previous = None  # this property holds the index of the previously played sound
        if not all(hasattr(sound, 'play') for sound in self):
            raise TypeError('Cannot play all of the provided items.')

    def play(self):
        idx = self.previous
        while idx == self.previous:
            idx = numpy.random.randint(len(self))
        self.previous = idx
        self[idx].play()

    def random_choice(self, n=1):
        'Return a random sample of sounds with replacement from the list.'
        idxs = numpy.random.randint(0, len(self), size=n)
        return [self[i] for i in idxs]

    def write(self, fname):
        fnames = list()
        for idx, sound in enumerate(self):
            f = f's_{idx}.wav'
            fnames.append(f)
            sound.write(f)
        with zipfile.ZipFile(fname, mode='w') as zip:
            for f in fnames:
                zip.write(f)


def load_config(config_file):
    '''
    Reads a text file with python varable assignments and returns
    a namedtuple with the variable names and values.
    Example:
    myconfig.txt:
    samplerate = 32000
    pause_duration = 30
    speeds = [60,120,180]
    >>> conf = load_config('myconfig.txt')
    >>> conf.speeds
    [60, 120, 180]
    '''
    from collections import namedtuple
    with open(config_file, 'r') as f:
        lines = f.readlines()
    if lines:
        var_names = []
        values = []
        for line in lines:
            var, val = line.strip().split('=')
            var_names.append(var.strip())
            values.append(eval(val.strip()))
        config_tuple = namedtuple('config', var_names)
        return config_tuple(*values)


if __name__ == '__main__':
    # Demonstration
    tr = Trialsequence(conditions=5, n_reps=2, name='test')
    stairs = Staircase(start_val=50, n_reversals=10, step_type='lin', step_sizes=[8, 4, 4, 2, 2, 1],  # reduce step size every two reversals
                       min_val=20, max_val=60, n_up=1, n_down=1, n_pretrials=4)
    for trial in stairs:
        response = stairs.simulate_response(30)
        stairs.add_response(response)
        stairs.print_trial_info()
        stairs.plot()
    print(f'reversals: {stairs.reversal_intensities}')
    print(f'mean of final 6 reversals: {stairs.threshold()}')
